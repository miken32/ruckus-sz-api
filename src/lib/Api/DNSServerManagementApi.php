<?php
/**
 * DNSServerManagementApi
 * PHP version 7.4
 *
 * @category Class
 * @package  PofP\SmartzoneClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Virtual SmartZone - High Scale
 *
 * This reference guide describes the public APIs supported by the Virtual SmartZone - High Scale 6.1.1. Use the RESTful API commands described in this guide as an alternative way to manage the controller and its managed APs (in addition to the web and command line interfaces).
 *
 * The version of the OpenAPI document: v11_1
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.2.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace PofP\SmartzoneClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use PofP\SmartzoneClient\ApiException;
use PofP\SmartzoneClient\Configuration;
use PofP\SmartzoneClient\HeaderSelector;
use PofP\SmartzoneClient\ObjectSerializer;

/**
 * DNSServerManagementApi Class Doc Comment
 *
 * @category Class
 * @package  PofP\SmartzoneClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DNSServerManagementApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addProfilesDnsserver' => [
            'application/json',
        ],
        'addProfilesDnsserverCloneById' => [
            'application/json',
        ],
        'deleteProfilesDnsserver' => [
            'application/json',
        ],
        'deleteProfilesDnsserverById' => [
            'application/json',
        ],
        'findProfilesDnsserver' => [
            'application/json',
        ],
        'findProfilesDnsserverById' => [
            'application/json',
        ],
        'findProfilesDnsserverByQueryCriteria' => [
            'application/json',
        ],
        'partialUpdateProfilesDnsserverById' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addProfilesDnsserver
     *
     * Use this API command to create DNS server profile.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addProfilesDnsserver'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |object
     */
    public function addProfilesDnsserver($service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['addProfilesDnsserver'][0])
    {
        list($response) = $this->addProfilesDnsserverWithHttpInfo($service_ticket, $UNKNOWN_PARAM_NAME, $contentType);
        return $response;
    }

    /**
     * Operation addProfilesDnsserverWithHttpInfo
     *
     * Use this API command to create DNS server profile.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addProfilesDnsserver'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |object, HTTP status code, HTTP response headers (array of strings)
     */
    public function addProfilesDnsserverWithHttpInfo($service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['addProfilesDnsserver'][0])
    {
        $request = $this->addProfilesDnsserverRequest($service_ticket, $UNKNOWN_PARAM_NAME, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addProfilesDnsserverAsync
     *
     * Use this API command to create DNS server profile.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addProfilesDnsserver'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addProfilesDnsserverAsync($service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['addProfilesDnsserver'][0])
    {
        return $this->addProfilesDnsserverAsyncWithHttpInfo($service_ticket, $UNKNOWN_PARAM_NAME, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addProfilesDnsserverAsyncWithHttpInfo
     *
     * Use this API command to create DNS server profile.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addProfilesDnsserver'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addProfilesDnsserverAsyncWithHttpInfo($service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['addProfilesDnsserver'][0])
    {
        $returnType = 'object';
        $request = $this->addProfilesDnsserverRequest($service_ticket, $UNKNOWN_PARAM_NAME, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addProfilesDnsserver'
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addProfilesDnsserver'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addProfilesDnsserverRequest($service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['addProfilesDnsserver'][0])
    {

        // verify the required parameter 'service_ticket' is set
        if ($service_ticket === null || (is_array($service_ticket) && count($service_ticket) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_ticket when calling addProfilesDnsserver'
            );
        }

        // verify the required parameter 'UNKNOWN_PARAM_NAME' is set
        if ($UNKNOWN_PARAM_NAME === null || (is_array($UNKNOWN_PARAM_NAME) && count($UNKNOWN_PARAM_NAME) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $UNKNOWN_PARAM_NAME when calling addProfilesDnsserver'
            );
        }


        $resourcePath = '/profiles/dnsserver';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_ticket,
            'serviceTicket', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($UNKNOWN_PARAM_NAME)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($UNKNOWN_PARAM_NAME));
            } else {
                $httpBody = $UNKNOWN_PARAM_NAME;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addProfilesDnsserverCloneById
     *
     * Use this API command to clone an DNS server profile.
     *
     * @param  string $id id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addProfilesDnsserverCloneById'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |object
     */
    public function addProfilesDnsserverCloneById($id, $service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['addProfilesDnsserverCloneById'][0])
    {
        list($response) = $this->addProfilesDnsserverCloneByIdWithHttpInfo($id, $service_ticket, $UNKNOWN_PARAM_NAME, $contentType);
        return $response;
    }

    /**
     * Operation addProfilesDnsserverCloneByIdWithHttpInfo
     *
     * Use this API command to clone an DNS server profile.
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addProfilesDnsserverCloneById'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |object, HTTP status code, HTTP response headers (array of strings)
     */
    public function addProfilesDnsserverCloneByIdWithHttpInfo($id, $service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['addProfilesDnsserverCloneById'][0])
    {
        $request = $this->addProfilesDnsserverCloneByIdRequest($id, $service_ticket, $UNKNOWN_PARAM_NAME, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addProfilesDnsserverCloneByIdAsync
     *
     * Use this API command to clone an DNS server profile.
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addProfilesDnsserverCloneById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addProfilesDnsserverCloneByIdAsync($id, $service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['addProfilesDnsserverCloneById'][0])
    {
        return $this->addProfilesDnsserverCloneByIdAsyncWithHttpInfo($id, $service_ticket, $UNKNOWN_PARAM_NAME, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addProfilesDnsserverCloneByIdAsyncWithHttpInfo
     *
     * Use this API command to clone an DNS server profile.
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addProfilesDnsserverCloneById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addProfilesDnsserverCloneByIdAsyncWithHttpInfo($id, $service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['addProfilesDnsserverCloneById'][0])
    {
        $returnType = 'object';
        $request = $this->addProfilesDnsserverCloneByIdRequest($id, $service_ticket, $UNKNOWN_PARAM_NAME, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addProfilesDnsserverCloneById'
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addProfilesDnsserverCloneById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addProfilesDnsserverCloneByIdRequest($id, $service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['addProfilesDnsserverCloneById'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling addProfilesDnsserverCloneById'
            );
        }

        // verify the required parameter 'service_ticket' is set
        if ($service_ticket === null || (is_array($service_ticket) && count($service_ticket) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_ticket when calling addProfilesDnsserverCloneById'
            );
        }

        // verify the required parameter 'UNKNOWN_PARAM_NAME' is set
        if ($UNKNOWN_PARAM_NAME === null || (is_array($UNKNOWN_PARAM_NAME) && count($UNKNOWN_PARAM_NAME) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $UNKNOWN_PARAM_NAME when calling addProfilesDnsserverCloneById'
            );
        }


        $resourcePath = '/profiles/dnsserver/clone/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_ticket,
            'serviceTicket', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($UNKNOWN_PARAM_NAME)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($UNKNOWN_PARAM_NAME));
            } else {
                $httpBody = $UNKNOWN_PARAM_NAME;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProfilesDnsserver
     *
     * Use this API command to delete a list of DNS server profile.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProfilesDnsserver'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |object
     */
    public function deleteProfilesDnsserver($service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['deleteProfilesDnsserver'][0])
    {
        list($response) = $this->deleteProfilesDnsserverWithHttpInfo($service_ticket, $UNKNOWN_PARAM_NAME, $contentType);
        return $response;
    }

    /**
     * Operation deleteProfilesDnsserverWithHttpInfo
     *
     * Use this API command to delete a list of DNS server profile.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProfilesDnsserver'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteProfilesDnsserverWithHttpInfo($service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['deleteProfilesDnsserver'][0])
    {
        $request = $this->deleteProfilesDnsserverRequest($service_ticket, $UNKNOWN_PARAM_NAME, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 204:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteProfilesDnsserverAsync
     *
     * Use this API command to delete a list of DNS server profile.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProfilesDnsserver'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProfilesDnsserverAsync($service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['deleteProfilesDnsserver'][0])
    {
        return $this->deleteProfilesDnsserverAsyncWithHttpInfo($service_ticket, $UNKNOWN_PARAM_NAME, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteProfilesDnsserverAsyncWithHttpInfo
     *
     * Use this API command to delete a list of DNS server profile.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProfilesDnsserver'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProfilesDnsserverAsyncWithHttpInfo($service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['deleteProfilesDnsserver'][0])
    {
        $returnType = 'object';
        $request = $this->deleteProfilesDnsserverRequest($service_ticket, $UNKNOWN_PARAM_NAME, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProfilesDnsserver'
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProfilesDnsserver'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteProfilesDnsserverRequest($service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['deleteProfilesDnsserver'][0])
    {

        // verify the required parameter 'service_ticket' is set
        if ($service_ticket === null || (is_array($service_ticket) && count($service_ticket) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_ticket when calling deleteProfilesDnsserver'
            );
        }

        // verify the required parameter 'UNKNOWN_PARAM_NAME' is set
        if ($UNKNOWN_PARAM_NAME === null || (is_array($UNKNOWN_PARAM_NAME) && count($UNKNOWN_PARAM_NAME) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $UNKNOWN_PARAM_NAME when calling deleteProfilesDnsserver'
            );
        }


        $resourcePath = '/profiles/dnsserver';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_ticket,
            'serviceTicket', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($UNKNOWN_PARAM_NAME)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($UNKNOWN_PARAM_NAME));
            } else {
                $httpBody = $UNKNOWN_PARAM_NAME;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProfilesDnsserverById
     *
     * Use this API command to delete DNS server profile.
     *
     * @param  string $id id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProfilesDnsserverById'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |object
     */
    public function deleteProfilesDnsserverById($id, $service_ticket, string $contentType = self::contentTypes['deleteProfilesDnsserverById'][0])
    {
        list($response) = $this->deleteProfilesDnsserverByIdWithHttpInfo($id, $service_ticket, $contentType);
        return $response;
    }

    /**
     * Operation deleteProfilesDnsserverByIdWithHttpInfo
     *
     * Use this API command to delete DNS server profile.
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProfilesDnsserverById'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteProfilesDnsserverByIdWithHttpInfo($id, $service_ticket, string $contentType = self::contentTypes['deleteProfilesDnsserverById'][0])
    {
        $request = $this->deleteProfilesDnsserverByIdRequest($id, $service_ticket, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 204:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteProfilesDnsserverByIdAsync
     *
     * Use this API command to delete DNS server profile.
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProfilesDnsserverById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProfilesDnsserverByIdAsync($id, $service_ticket, string $contentType = self::contentTypes['deleteProfilesDnsserverById'][0])
    {
        return $this->deleteProfilesDnsserverByIdAsyncWithHttpInfo($id, $service_ticket, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteProfilesDnsserverByIdAsyncWithHttpInfo
     *
     * Use this API command to delete DNS server profile.
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProfilesDnsserverById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProfilesDnsserverByIdAsyncWithHttpInfo($id, $service_ticket, string $contentType = self::contentTypes['deleteProfilesDnsserverById'][0])
    {
        $returnType = 'object';
        $request = $this->deleteProfilesDnsserverByIdRequest($id, $service_ticket, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProfilesDnsserverById'
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProfilesDnsserverById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteProfilesDnsserverByIdRequest($id, $service_ticket, string $contentType = self::contentTypes['deleteProfilesDnsserverById'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteProfilesDnsserverById'
            );
        }

        // verify the required parameter 'service_ticket' is set
        if ($service_ticket === null || (is_array($service_ticket) && count($service_ticket) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_ticket when calling deleteProfilesDnsserverById'
            );
        }


        $resourcePath = '/profiles/dnsserver/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_ticket,
            'serviceTicket', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findProfilesDnsserver
     *
     * Use this API command to retrieve a list of DNS server profile.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $index The index of the first entry to be retrieved. Default: 0 (optional)
     * @param  string $list_size The maximum number of entries to be retrieved. Default: 100, Maximum: 1000 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findProfilesDnsserver'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |object
     */
    public function findProfilesDnsserver($service_ticket, $index = null, $list_size = null, string $contentType = self::contentTypes['findProfilesDnsserver'][0])
    {
        list($response) = $this->findProfilesDnsserverWithHttpInfo($service_ticket, $index, $list_size, $contentType);
        return $response;
    }

    /**
     * Operation findProfilesDnsserverWithHttpInfo
     *
     * Use this API command to retrieve a list of DNS server profile.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $index The index of the first entry to be retrieved. Default: 0 (optional)
     * @param  string $list_size The maximum number of entries to be retrieved. Default: 100, Maximum: 1000 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findProfilesDnsserver'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |object, HTTP status code, HTTP response headers (array of strings)
     */
    public function findProfilesDnsserverWithHttpInfo($service_ticket, $index = null, $list_size = null, string $contentType = self::contentTypes['findProfilesDnsserver'][0])
    {
        $request = $this->findProfilesDnsserverRequest($service_ticket, $index, $list_size, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findProfilesDnsserverAsync
     *
     * Use this API command to retrieve a list of DNS server profile.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $index The index of the first entry to be retrieved. Default: 0 (optional)
     * @param  string $list_size The maximum number of entries to be retrieved. Default: 100, Maximum: 1000 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findProfilesDnsserver'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findProfilesDnsserverAsync($service_ticket, $index = null, $list_size = null, string $contentType = self::contentTypes['findProfilesDnsserver'][0])
    {
        return $this->findProfilesDnsserverAsyncWithHttpInfo($service_ticket, $index, $list_size, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findProfilesDnsserverAsyncWithHttpInfo
     *
     * Use this API command to retrieve a list of DNS server profile.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $index The index of the first entry to be retrieved. Default: 0 (optional)
     * @param  string $list_size The maximum number of entries to be retrieved. Default: 100, Maximum: 1000 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findProfilesDnsserver'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findProfilesDnsserverAsyncWithHttpInfo($service_ticket, $index = null, $list_size = null, string $contentType = self::contentTypes['findProfilesDnsserver'][0])
    {
        $returnType = 'object';
        $request = $this->findProfilesDnsserverRequest($service_ticket, $index, $list_size, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findProfilesDnsserver'
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $index The index of the first entry to be retrieved. Default: 0 (optional)
     * @param  string $list_size The maximum number of entries to be retrieved. Default: 100, Maximum: 1000 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findProfilesDnsserver'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function findProfilesDnsserverRequest($service_ticket, $index = null, $list_size = null, string $contentType = self::contentTypes['findProfilesDnsserver'][0])
    {

        // verify the required parameter 'service_ticket' is set
        if ($service_ticket === null || (is_array($service_ticket) && count($service_ticket) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_ticket when calling findProfilesDnsserver'
            );
        }




        $resourcePath = '/profiles/dnsserver';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_ticket,
            'serviceTicket', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $index,
            'index', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $list_size,
            'listSize', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findProfilesDnsserverById
     *
     * Use this API command to retrieve DNS server profile.
     *
     * @param  string $id id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findProfilesDnsserverById'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |object
     */
    public function findProfilesDnsserverById($id, $service_ticket, string $contentType = self::contentTypes['findProfilesDnsserverById'][0])
    {
        list($response) = $this->findProfilesDnsserverByIdWithHttpInfo($id, $service_ticket, $contentType);
        return $response;
    }

    /**
     * Operation findProfilesDnsserverByIdWithHttpInfo
     *
     * Use this API command to retrieve DNS server profile.
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findProfilesDnsserverById'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |object, HTTP status code, HTTP response headers (array of strings)
     */
    public function findProfilesDnsserverByIdWithHttpInfo($id, $service_ticket, string $contentType = self::contentTypes['findProfilesDnsserverById'][0])
    {
        $request = $this->findProfilesDnsserverByIdRequest($id, $service_ticket, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findProfilesDnsserverByIdAsync
     *
     * Use this API command to retrieve DNS server profile.
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findProfilesDnsserverById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findProfilesDnsserverByIdAsync($id, $service_ticket, string $contentType = self::contentTypes['findProfilesDnsserverById'][0])
    {
        return $this->findProfilesDnsserverByIdAsyncWithHttpInfo($id, $service_ticket, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findProfilesDnsserverByIdAsyncWithHttpInfo
     *
     * Use this API command to retrieve DNS server profile.
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findProfilesDnsserverById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findProfilesDnsserverByIdAsyncWithHttpInfo($id, $service_ticket, string $contentType = self::contentTypes['findProfilesDnsserverById'][0])
    {
        $returnType = 'object';
        $request = $this->findProfilesDnsserverByIdRequest($id, $service_ticket, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findProfilesDnsserverById'
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findProfilesDnsserverById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function findProfilesDnsserverByIdRequest($id, $service_ticket, string $contentType = self::contentTypes['findProfilesDnsserverById'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling findProfilesDnsserverById'
            );
        }

        // verify the required parameter 'service_ticket' is set
        if ($service_ticket === null || (is_array($service_ticket) && count($service_ticket) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_ticket when calling findProfilesDnsserverById'
            );
        }


        $resourcePath = '/profiles/dnsserver/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_ticket,
            'serviceTicket', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findProfilesDnsserverByQueryCriteria
     *
     * Use this API command to retrieve a list of DNS server profile  by query criteria.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  \PofP\SmartzoneClient\Model\CommonQueryCriteriaSuperSet $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findProfilesDnsserverByQueryCriteria'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |object
     */
    public function findProfilesDnsserverByQueryCriteria($service_ticket, $body, string $contentType = self::contentTypes['findProfilesDnsserverByQueryCriteria'][0])
    {
        list($response) = $this->findProfilesDnsserverByQueryCriteriaWithHttpInfo($service_ticket, $body, $contentType);
        return $response;
    }

    /**
     * Operation findProfilesDnsserverByQueryCriteriaWithHttpInfo
     *
     * Use this API command to retrieve a list of DNS server profile  by query criteria.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  \PofP\SmartzoneClient\Model\CommonQueryCriteriaSuperSet $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findProfilesDnsserverByQueryCriteria'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |object, HTTP status code, HTTP response headers (array of strings)
     */
    public function findProfilesDnsserverByQueryCriteriaWithHttpInfo($service_ticket, $body, string $contentType = self::contentTypes['findProfilesDnsserverByQueryCriteria'][0])
    {
        $request = $this->findProfilesDnsserverByQueryCriteriaRequest($service_ticket, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findProfilesDnsserverByQueryCriteriaAsync
     *
     * Use this API command to retrieve a list of DNS server profile  by query criteria.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  \PofP\SmartzoneClient\Model\CommonQueryCriteriaSuperSet $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findProfilesDnsserverByQueryCriteria'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findProfilesDnsserverByQueryCriteriaAsync($service_ticket, $body, string $contentType = self::contentTypes['findProfilesDnsserverByQueryCriteria'][0])
    {
        return $this->findProfilesDnsserverByQueryCriteriaAsyncWithHttpInfo($service_ticket, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findProfilesDnsserverByQueryCriteriaAsyncWithHttpInfo
     *
     * Use this API command to retrieve a list of DNS server profile  by query criteria.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  \PofP\SmartzoneClient\Model\CommonQueryCriteriaSuperSet $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findProfilesDnsserverByQueryCriteria'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findProfilesDnsserverByQueryCriteriaAsyncWithHttpInfo($service_ticket, $body, string $contentType = self::contentTypes['findProfilesDnsserverByQueryCriteria'][0])
    {
        $returnType = 'object';
        $request = $this->findProfilesDnsserverByQueryCriteriaRequest($service_ticket, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findProfilesDnsserverByQueryCriteria'
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  \PofP\SmartzoneClient\Model\CommonQueryCriteriaSuperSet $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findProfilesDnsserverByQueryCriteria'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function findProfilesDnsserverByQueryCriteriaRequest($service_ticket, $body, string $contentType = self::contentTypes['findProfilesDnsserverByQueryCriteria'][0])
    {

        // verify the required parameter 'service_ticket' is set
        if ($service_ticket === null || (is_array($service_ticket) && count($service_ticket) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_ticket when calling findProfilesDnsserverByQueryCriteria'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling findProfilesDnsserverByQueryCriteria'
            );
        }


        $resourcePath = '/profiles/dnsserver/query';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_ticket,
            'serviceTicket', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation partialUpdateProfilesDnsserverById
     *
     * Use this API command to modify the configuration of DNS server profile.
     *
     * @param  string $id id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['partialUpdateProfilesDnsserverById'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |object
     */
    public function partialUpdateProfilesDnsserverById($id, $service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['partialUpdateProfilesDnsserverById'][0])
    {
        list($response) = $this->partialUpdateProfilesDnsserverByIdWithHttpInfo($id, $service_ticket, $UNKNOWN_PARAM_NAME, $contentType);
        return $response;
    }

    /**
     * Operation partialUpdateProfilesDnsserverByIdWithHttpInfo
     *
     * Use this API command to modify the configuration of DNS server profile.
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['partialUpdateProfilesDnsserverById'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |object, HTTP status code, HTTP response headers (array of strings)
     */
    public function partialUpdateProfilesDnsserverByIdWithHttpInfo($id, $service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['partialUpdateProfilesDnsserverById'][0])
    {
        $request = $this->partialUpdateProfilesDnsserverByIdRequest($id, $service_ticket, $UNKNOWN_PARAM_NAME, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 204:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation partialUpdateProfilesDnsserverByIdAsync
     *
     * Use this API command to modify the configuration of DNS server profile.
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['partialUpdateProfilesDnsserverById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function partialUpdateProfilesDnsserverByIdAsync($id, $service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['partialUpdateProfilesDnsserverById'][0])
    {
        return $this->partialUpdateProfilesDnsserverByIdAsyncWithHttpInfo($id, $service_ticket, $UNKNOWN_PARAM_NAME, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation partialUpdateProfilesDnsserverByIdAsyncWithHttpInfo
     *
     * Use this API command to modify the configuration of DNS server profile.
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['partialUpdateProfilesDnsserverById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function partialUpdateProfilesDnsserverByIdAsyncWithHttpInfo($id, $service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['partialUpdateProfilesDnsserverById'][0])
    {
        $returnType = 'object';
        $request = $this->partialUpdateProfilesDnsserverByIdRequest($id, $service_ticket, $UNKNOWN_PARAM_NAME, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'partialUpdateProfilesDnsserverById'
     *
     * @param  string $id (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['partialUpdateProfilesDnsserverById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function partialUpdateProfilesDnsserverByIdRequest($id, $service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['partialUpdateProfilesDnsserverById'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling partialUpdateProfilesDnsserverById'
            );
        }

        // verify the required parameter 'service_ticket' is set
        if ($service_ticket === null || (is_array($service_ticket) && count($service_ticket) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_ticket when calling partialUpdateProfilesDnsserverById'
            );
        }

        // verify the required parameter 'UNKNOWN_PARAM_NAME' is set
        if ($UNKNOWN_PARAM_NAME === null || (is_array($UNKNOWN_PARAM_NAME) && count($UNKNOWN_PARAM_NAME) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $UNKNOWN_PARAM_NAME when calling partialUpdateProfilesDnsserverById'
            );
        }


        $resourcePath = '/profiles/dnsserver/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_ticket,
            'serviceTicket', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($UNKNOWN_PARAM_NAME)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($UNKNOWN_PARAM_NAME));
            } else {
                $httpBody = $UNKNOWN_PARAM_NAME;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
