<?php
/**
 * ConnectivityToolsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  PofP\SmartzoneClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Virtual SmartZone - High Scale
 *
 * This reference guide describes the public APIs supported by the Virtual SmartZone - High Scale 6.1.1. Use the RESTful API commands described in this guide as an alternative way to manage the controller and its managed APs (in addition to the web and command line interfaces).
 *
 * The version of the OpenAPI document: v11_1
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.2.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace PofP\SmartzoneClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use PofP\SmartzoneClient\ApiException;
use PofP\SmartzoneClient\Configuration;
use PofP\SmartzoneClient\HeaderSelector;
use PofP\SmartzoneClient\ObjectSerializer;

/**
 * ConnectivityToolsApi Class Doc Comment
 *
 * @category Class
 * @package  PofP\SmartzoneClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ConnectivityToolsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addToolSpeedflex' => [
            'application/json',
        ],
        'findToolPing' => [
            'application/json',
        ],
        'findToolSpeedflexByWcid' => [
            'application/json',
        ],
        'findToolTraceRoute' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addToolSpeedflex
     *
     * Use this API command to start the SpeedFlex test.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addToolSpeedflex'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |object
     */
    public function addToolSpeedflex($service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['addToolSpeedflex'][0])
    {
        list($response) = $this->addToolSpeedflexWithHttpInfo($service_ticket, $UNKNOWN_PARAM_NAME, $contentType);
        return $response;
    }

    /**
     * Operation addToolSpeedflexWithHttpInfo
     *
     * Use this API command to start the SpeedFlex test.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addToolSpeedflex'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |object, HTTP status code, HTTP response headers (array of strings)
     */
    public function addToolSpeedflexWithHttpInfo($service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['addToolSpeedflex'][0])
    {
        $request = $this->addToolSpeedflexRequest($service_ticket, $UNKNOWN_PARAM_NAME, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addToolSpeedflexAsync
     *
     * Use this API command to start the SpeedFlex test.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addToolSpeedflex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addToolSpeedflexAsync($service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['addToolSpeedflex'][0])
    {
        return $this->addToolSpeedflexAsyncWithHttpInfo($service_ticket, $UNKNOWN_PARAM_NAME, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addToolSpeedflexAsyncWithHttpInfo
     *
     * Use this API command to start the SpeedFlex test.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addToolSpeedflex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addToolSpeedflexAsyncWithHttpInfo($service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['addToolSpeedflex'][0])
    {
        $returnType = 'object';
        $request = $this->addToolSpeedflexRequest($service_ticket, $UNKNOWN_PARAM_NAME, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addToolSpeedflex'
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param   $UNKNOWN_PARAM_NAME (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addToolSpeedflex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addToolSpeedflexRequest($service_ticket, $UNKNOWN_PARAM_NAME, string $contentType = self::contentTypes['addToolSpeedflex'][0])
    {

        // verify the required parameter 'service_ticket' is set
        if ($service_ticket === null || (is_array($service_ticket) && count($service_ticket) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_ticket when calling addToolSpeedflex'
            );
        }

        // verify the required parameter 'UNKNOWN_PARAM_NAME' is set
        if ($UNKNOWN_PARAM_NAME === null || (is_array($UNKNOWN_PARAM_NAME) && count($UNKNOWN_PARAM_NAME) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $UNKNOWN_PARAM_NAME when calling addToolSpeedflex'
            );
        }


        $resourcePath = '/tool/speedflex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_ticket,
            'serviceTicket', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($UNKNOWN_PARAM_NAME)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($UNKNOWN_PARAM_NAME));
            } else {
                $httpBody = $UNKNOWN_PARAM_NAME;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findToolPing
     *
     * Use this API command to run the PING test on an AP.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $ap_mac MAC address of the AP running the PING test (required)
     * @param  string $target_ip the IP address to PING (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findToolPing'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |string
     */
    public function findToolPing($service_ticket, $ap_mac, $target_ip, string $contentType = self::contentTypes['findToolPing'][0])
    {
        list($response) = $this->findToolPingWithHttpInfo($service_ticket, $ap_mac, $target_ip, $contentType);
        return $response;
    }

    /**
     * Operation findToolPingWithHttpInfo
     *
     * Use this API command to run the PING test on an AP.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $ap_mac MAC address of the AP running the PING test (required)
     * @param  string $target_ip the IP address to PING (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findToolPing'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |string, HTTP status code, HTTP response headers (array of strings)
     */
    public function findToolPingWithHttpInfo($service_ticket, $ap_mac, $target_ip, string $contentType = self::contentTypes['findToolPing'][0])
    {
        $request = $this->findToolPingRequest($service_ticket, $ap_mac, $target_ip, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findToolPingAsync
     *
     * Use this API command to run the PING test on an AP.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $ap_mac MAC address of the AP running the PING test (required)
     * @param  string $target_ip the IP address to PING (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findToolPing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findToolPingAsync($service_ticket, $ap_mac, $target_ip, string $contentType = self::contentTypes['findToolPing'][0])
    {
        return $this->findToolPingAsyncWithHttpInfo($service_ticket, $ap_mac, $target_ip, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findToolPingAsyncWithHttpInfo
     *
     * Use this API command to run the PING test on an AP.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $ap_mac MAC address of the AP running the PING test (required)
     * @param  string $target_ip the IP address to PING (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findToolPing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findToolPingAsyncWithHttpInfo($service_ticket, $ap_mac, $target_ip, string $contentType = self::contentTypes['findToolPing'][0])
    {
        $returnType = 'string';
        $request = $this->findToolPingRequest($service_ticket, $ap_mac, $target_ip, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findToolPing'
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $ap_mac MAC address of the AP running the PING test (required)
     * @param  string $target_ip the IP address to PING (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findToolPing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function findToolPingRequest($service_ticket, $ap_mac, $target_ip, string $contentType = self::contentTypes['findToolPing'][0])
    {

        // verify the required parameter 'service_ticket' is set
        if ($service_ticket === null || (is_array($service_ticket) && count($service_ticket) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_ticket when calling findToolPing'
            );
        }

        // verify the required parameter 'ap_mac' is set
        if ($ap_mac === null || (is_array($ap_mac) && count($ap_mac) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ap_mac when calling findToolPing'
            );
        }

        // verify the required parameter 'target_ip' is set
        if ($target_ip === null || (is_array($target_ip) && count($target_ip) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $target_ip when calling findToolPing'
            );
        }


        $resourcePath = '/tool/ping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_ticket,
            'serviceTicket', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ap_mac,
            'apMac', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target_ip,
            'targetIP', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findToolSpeedflexByWcid
     *
     * Use this API command to retrieve existing SpeedFlex test results.
     *
     * @param  string $wcid wcid (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findToolSpeedflexByWcid'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |object
     */
    public function findToolSpeedflexByWcid($wcid, $service_ticket, string $contentType = self::contentTypes['findToolSpeedflexByWcid'][0])
    {
        list($response) = $this->findToolSpeedflexByWcidWithHttpInfo($wcid, $service_ticket, $contentType);
        return $response;
    }

    /**
     * Operation findToolSpeedflexByWcidWithHttpInfo
     *
     * Use this API command to retrieve existing SpeedFlex test results.
     *
     * @param  string $wcid (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findToolSpeedflexByWcid'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |object, HTTP status code, HTTP response headers (array of strings)
     */
    public function findToolSpeedflexByWcidWithHttpInfo($wcid, $service_ticket, string $contentType = self::contentTypes['findToolSpeedflexByWcid'][0])
    {
        $request = $this->findToolSpeedflexByWcidRequest($wcid, $service_ticket, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findToolSpeedflexByWcidAsync
     *
     * Use this API command to retrieve existing SpeedFlex test results.
     *
     * @param  string $wcid (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findToolSpeedflexByWcid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findToolSpeedflexByWcidAsync($wcid, $service_ticket, string $contentType = self::contentTypes['findToolSpeedflexByWcid'][0])
    {
        return $this->findToolSpeedflexByWcidAsyncWithHttpInfo($wcid, $service_ticket, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findToolSpeedflexByWcidAsyncWithHttpInfo
     *
     * Use this API command to retrieve existing SpeedFlex test results.
     *
     * @param  string $wcid (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findToolSpeedflexByWcid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findToolSpeedflexByWcidAsyncWithHttpInfo($wcid, $service_ticket, string $contentType = self::contentTypes['findToolSpeedflexByWcid'][0])
    {
        $returnType = 'object';
        $request = $this->findToolSpeedflexByWcidRequest($wcid, $service_ticket, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findToolSpeedflexByWcid'
     *
     * @param  string $wcid (required)
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findToolSpeedflexByWcid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function findToolSpeedflexByWcidRequest($wcid, $service_ticket, string $contentType = self::contentTypes['findToolSpeedflexByWcid'][0])
    {

        // verify the required parameter 'wcid' is set
        if ($wcid === null || (is_array($wcid) && count($wcid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wcid when calling findToolSpeedflexByWcid'
            );
        }

        // verify the required parameter 'service_ticket' is set
        if ($service_ticket === null || (is_array($service_ticket) && count($service_ticket) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_ticket when calling findToolSpeedflexByWcid'
            );
        }


        $resourcePath = '/tool/speedflex/{wcid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_ticket,
            'serviceTicket', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($wcid !== null) {
            $resourcePath = str_replace(
                '{' . 'wcid' . '}',
                ObjectSerializer::toPathValue($wcid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findToolTraceRoute
     *
     * Use this API command to run the traceroute test on an AP.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $ap_mac MAC address of the AP running the traceRoute test (required)
     * @param  string $target_ip the target IP address to traceRoute (required)
     * @param  string $timeout_in_sec Timeout in unit of seconds (Default: 30) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findToolTraceRoute'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |string
     */
    public function findToolTraceRoute($service_ticket, $ap_mac, $target_ip, $timeout_in_sec = null, string $contentType = self::contentTypes['findToolTraceRoute'][0])
    {
        list($response) = $this->findToolTraceRouteWithHttpInfo($service_ticket, $ap_mac, $target_ip, $timeout_in_sec, $contentType);
        return $response;
    }

    /**
     * Operation findToolTraceRouteWithHttpInfo
     *
     * Use this API command to run the traceroute test on an AP.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $ap_mac MAC address of the AP running the traceRoute test (required)
     * @param  string $target_ip the target IP address to traceRoute (required)
     * @param  string $timeout_in_sec Timeout in unit of seconds (Default: 30) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findToolTraceRoute'] to see the possible values for this operation
     *
     * @throws \PofP\SmartzoneClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |string, HTTP status code, HTTP response headers (array of strings)
     */
    public function findToolTraceRouteWithHttpInfo($service_ticket, $ap_mac, $target_ip, $timeout_in_sec = null, string $contentType = self::contentTypes['findToolTraceRoute'][0])
    {
        $request = $this->findToolTraceRouteRequest($service_ticket, $ap_mac, $target_ip, $timeout_in_sec, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                 );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findToolTraceRouteAsync
     *
     * Use this API command to run the traceroute test on an AP.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $ap_mac MAC address of the AP running the traceRoute test (required)
     * @param  string $target_ip the target IP address to traceRoute (required)
     * @param  string $timeout_in_sec Timeout in unit of seconds (Default: 30) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findToolTraceRoute'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findToolTraceRouteAsync($service_ticket, $ap_mac, $target_ip, $timeout_in_sec = null, string $contentType = self::contentTypes['findToolTraceRoute'][0])
    {
        return $this->findToolTraceRouteAsyncWithHttpInfo($service_ticket, $ap_mac, $target_ip, $timeout_in_sec, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findToolTraceRouteAsyncWithHttpInfo
     *
     * Use this API command to run the traceroute test on an AP.
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $ap_mac MAC address of the AP running the traceRoute test (required)
     * @param  string $target_ip the target IP address to traceRoute (required)
     * @param  string $timeout_in_sec Timeout in unit of seconds (Default: 30) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findToolTraceRoute'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findToolTraceRouteAsyncWithHttpInfo($service_ticket, $ap_mac, $target_ip, $timeout_in_sec = null, string $contentType = self::contentTypes['findToolTraceRoute'][0])
    {
        $returnType = 'string';
        $request = $this->findToolTraceRouteRequest($service_ticket, $ap_mac, $target_ip, $timeout_in_sec, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findToolTraceRoute'
     *
     * @param  string $service_ticket Service Ticket is required in the Request URI Parameters of all API requests (except for the logon API). (required)
     * @param  string $ap_mac MAC address of the AP running the traceRoute test (required)
     * @param  string $target_ip the target IP address to traceRoute (required)
     * @param  string $timeout_in_sec Timeout in unit of seconds (Default: 30) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findToolTraceRoute'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function findToolTraceRouteRequest($service_ticket, $ap_mac, $target_ip, $timeout_in_sec = null, string $contentType = self::contentTypes['findToolTraceRoute'][0])
    {

        // verify the required parameter 'service_ticket' is set
        if ($service_ticket === null || (is_array($service_ticket) && count($service_ticket) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_ticket when calling findToolTraceRoute'
            );
        }

        // verify the required parameter 'ap_mac' is set
        if ($ap_mac === null || (is_array($ap_mac) && count($ap_mac) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ap_mac when calling findToolTraceRoute'
            );
        }

        // verify the required parameter 'target_ip' is set
        if ($target_ip === null || (is_array($target_ip) && count($target_ip) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $target_ip when calling findToolTraceRoute'
            );
        }



        $resourcePath = '/tool/traceRoute';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_ticket,
            'serviceTicket', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ap_mac,
            'apMac', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target_ip,
            'targetIP', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timeout_in_sec,
            'timeoutInSec', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
